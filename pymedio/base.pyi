import builtins
import typing

import numpy as np
import numpy.typing as npt

import pymedio.typing as miot

_UfuncMethod = typing.Literal[
    "__call__", "reduce", "reduceat", "accumulate", "outer", "inner"
]
T = typing.TypeVar("T", bound=np.ndarray)
S = typing.TypeVar("S", bound=np.ndarray)

class BasicImage(np.ndarray):
    _HANDLED_TYPES: typing.ClassVar[typing.Tuple[typing.Type, ...]]
    _affine: npt.NDArray
    def __new__(cls, data: npt.ArrayLike, affine: npt.NDArray | None = ...) -> T: ...  # type: ignore[misc]
    def __array_finalize__(self, obj: builtins.object) -> None: ...  # type: ignore[override]
    def __array_ufunc__(
        self,
        ufunc: np.ufunc,
        method: _UfuncMethod,
        *inputs: typing.Any,
        **kwargs: typing.Any,
    ) -> typing.Any: ...
    @property
    def repr_properties(self) -> typing.List[builtins.str]: ...
    @property
    def affine(self) -> npt.NDArray: ...
    @affine.setter
    def affine(self, new_affine: npt.NDArray) -> None: ...
    @property
    def direction(self) -> miot.Direction: ...
    @property
    def spacing(self) -> typing.Tuple[builtins.float, ...]: ...
    @property
    def origin(self) -> typing.Tuple[builtins.float, ...]: ...
    @property
    def memory(self) -> builtins.int: ...
    def get_spacing_string(self) -> builtins.str: ...
    def to_npz(self, file: miot.PathLike | typing.BinaryIO) -> None: ...
    @classmethod
    def from_npz(cls, file: miot.PathLike | typing.BinaryIO) -> T: ...
    def torch_compatible(self) -> npt.NDArray: ...
    def __getitem__(self: T, key: typing.Any) -> T: ...
    def __lt__(self: T, other: typing.Any) -> S: ...
    def __le__(self: T, other: typing.Any) -> S: ...
    def __gt__(self: T, other: typing.Any) -> S: ...
    def __ge__(self: T, other: typing.Any) -> S: ...
    def __abs__(self: T) -> T: ...
    def __invert__(self: T) -> T: ...
    def __neg__(self: T) -> T: ...
    def __matmul__(self: T, other: typing.Any) -> T: ...
    def __rmatmul__(self: T, other: typing.Any) -> T: ...
    def __mod__(self: T, other: typing.Any) -> T: ...
    def __rmod__(self: T, other: typing.Any) -> T: ...
    def __divmod__(self: T, other: typing.Any) -> typing.Tuple[T, T]: ...
    def __rdivmod__(self: T, other: typing.Any) -> typing.Tuple[T, T]: ...
    def __add__(self: T, other: typing.Any) -> T: ...
    def __radd__(self: T, other: typing.Any) -> T: ...
    def __iadd__(self: T, other: typing.Any) -> T: ...
    def __sub__(self: T, other: typing.Any) -> S: ...
    def __rsub__(self: T, other: typing.Any) -> S: ...
    def __isub__(self: T, other: typing.Any) -> S: ...
    def __mul__(self: T, other: typing.Any) -> T: ...
    def __rmul__(self: T, other: typing.Any) -> T: ...
    def __imul__(self: T, other: typing.Any) -> T: ...
    def __floordiv__(self: T, other: typing.Any) -> S: ...
    def __rfloordiv__(self: T, other: typing.Any) -> S: ...
    def __ifloordiv__(self: T, other: typing.Any) -> S: ...
    def __pow__(self: T, other: typing.Any) -> T: ...
    def __rpow__(self: T, other: typing.Any) -> T: ...
    def __ipow__(self: T, other: typing.Any) -> T: ...
    def __truediv__(self: T, other: typing.Any) -> S: ...
    def __rtruediv__(self: T, other: typing.Any) -> S: ...
    def __itruediv__(self: T, other: typing.Any) -> S: ...
    def __lshift__(self: T, other: typing.Any) -> T: ...
    def __rlshift__(self: T, other: typing.Any) -> T: ...
    def __ilshift__(self: T, other: typing.Any) -> T: ...
    def __rshift__(self: T, other: typing.Any) -> T: ...
    def __rrshift__(self: T, other: typing.Any) -> T: ...
    def __irshift__(self: T, other: typing.Any) -> T: ...
    def __and__(self: T, other: typing.Any) -> T: ...
    def __rand__(self: T, other: typing.Any) -> T: ...
    def __iand__(self: T, other: typing.Any) -> T: ...
    def __xor__(self: T, other: typing.Any) -> T: ...
    def __rxor__(self: T, other: typing.Any) -> T: ...
    def __ixor__(self: T, other: typing.Any) -> T: ...
    def __or__(self: T, other: typing.Any) -> T: ...
    def __ror__(self: T, other: typing.Any) -> T: ...
    def __ior__(self: T, other: typing.Any) -> T: ...
    def byteswap(self: T, inplace: builtins.bool = ...) -> T: ...
    def squeeze(
        self: T,
        axis: typing.SupportsIndex | typing.Sequence[typing.SupportsIndex] = ...,
    ) -> T: ...
    def swapaxes(
        self: T, axis1: typing.SupportsIndex, axis2: typing.SupportsIndex
    ) -> T: ...
    @typing.overload
    def transpose(self: T, axes: miot.ShapeLike, /) -> T: ...
    @typing.overload
    def transpose(self: T, *axes: typing.SupportsIndex) -> T: ...
    def dot(self: T, b: npt.ArrayLike, out: S | None = ...) -> S: ...
    def astype(  # type: ignore[override]
        self: T,
        dtype: npt.DTypeLike,
        order: typing.Literal["A", "C", "F", "K"] | None = ...,
        casting: typing.Literal["no", "equiv", "safe", "same_kind", "unsafe"] = ...,
        subok: builtins.bool = ...,
        copy: builtins.bool = ...,
    ) -> T: ...
    @typing.overload
    def reshape(
        self: T,
        shape: miot.ShapeLike,
        order: typing.Literal["A", "C", "F"] | None = ...,
    ) -> T: ...
    @typing.overload
    def reshape(
        self: T,
        *shape: typing.SupportsIndex,
        order: typing.Literal["A", "C", "F"] | None = ...,
    ) -> T: ...
    @typing.overload
    def view(self: T) -> T: ...
    @typing.overload
    def view(self, type: typing.Type[T]) -> T: ...
    @typing.overload
    def view(self: T, dtype: npt.DTypeLike) -> S: ...
    @typing.overload
    def view(self: T, dtype: npt.DTypeLike, type: typing.Type[S]) -> S: ...
    def flatten(
        self: T, order: typing.Literal["A", "C", "F", "K"] | None = ...
    ) -> T: ...
    def ravel(self: T, order: typing.Literal["A", "C", "F", "K"] | None = ...) -> T: ...
