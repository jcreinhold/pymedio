from __future__ import annotations

import collections.abc
import typing

import numpy as np
import numpy.typing as npt

import pymedio.typing as miot

_UfuncMethod = typing.Literal[
    "__call__", "reduce", "reduceat", "accumulate", "outer", "inner"
]
T = typing.TypeVar("T", bound="BasicImage")
S = typing.TypeVar("S", bound=np.ndarray)

class BasicImage(npt.NDArray[miot.DType]):
    _HANDLED_TYPES: typing.ClassVar[tuple[typing.Type, ...]]
    _affine: npt.NDArray
    def __new__(
        cls,
        data: npt.ArrayLike,
        affine: npt.NDArray | None = ...,
        info: typing.Any = ...,
    ) -> BasicImage: ...
    def __array_finalize__(self, obj: object) -> None: ...
    def __array_ufunc__(
        self,
        ufunc: np.ufunc,
        method: _UfuncMethod,
        *inputs: typing.Any,
        **kwargs: typing.Any,
    ) -> typing.Any: ...
    @property
    def repr_properties(self) -> list[str]: ...
    @property
    def affine(self) -> npt.NDArray: ...
    @affine.setter
    def affine(self, new_affine: npt.NDArray) -> None: ...
    @property
    def info(self) -> npt.NDArray[np.str_]: ...
    @affine.setter
    def info(self, new_info: str | npt.NDArray[np.str_] | None) -> None: ...
    @property
    def direction(self) -> miot.Direction: ...
    @property
    def spacing(self) -> tuple[float, ...]: ...
    @property
    def origin(self) -> tuple[float, ...]: ...
    @property
    def memory(self) -> int: ...
    def get_spacing_string(self) -> str: ...
    def to_npz(self, file: miot.PathLike | typing.BinaryIO) -> None: ...
    @classmethod
    def from_npz(cls: typing.Type[T], file: miot.PathLike | typing.BinaryIO) -> T: ...
    def torch_compatible(self) -> npt.NDArray: ...
    def resample_image(self, shape: collections.abc.Sequence[int]) -> BasicImage: ...
    def __getitem__(self: T, key: typing.Any) -> T: ...
    def __lt__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __le__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __gt__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __ge__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __abs__(self: T) -> T: ...  # type: ignore[override]
    def __invert__(self: T) -> T: ...  # type: ignore[override]
    def __neg__(self: T) -> T: ...  # type: ignore[override]
    def __matmul__(self: T, other: typing.Any) -> T: ...
    def __rmatmul__(self: T, other: typing.Any) -> T: ...
    def __mod__(self: T, other: typing.Any) -> T: ...
    def __rmod__(self: T, other: typing.Any) -> T: ...
    def __divmod__(self: T, other: typing.Any) -> tuple[T, T]: ...  # type: ignore[override]
    def __rdivmod__(self: T, other: typing.Any) -> tuple[T, T]: ...  # type: ignore[override]
    def __add__(self: T, other: typing.Any) -> T: ...
    def __radd__(self: T, other: typing.Any) -> T: ...
    def __iadd__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __sub__(self: T, other: typing.Any) -> T: ...
    def __rsub__(self: T, other: typing.Any) -> T: ...
    def __isub__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __mul__(self: T, other: typing.Any) -> T: ...
    def __rmul__(self: T, other: typing.Any) -> T: ...
    def __imul__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __floordiv__(self: T, other: typing.Any) -> T: ...
    def __rfloordiv__(self: T, other: typing.Any) -> T: ...
    def __ifloordiv__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __pow__(self: T, other: typing.Any) -> T: ...
    def __rpow__(self: T, other: typing.Any) -> T: ...
    def __ipow__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __truediv__(self: T, other: typing.Any) -> T: ...
    def __rtruediv__(self: T, other: typing.Any) -> T: ...
    def __itruediv__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __lshift__(self: T, other: typing.Any) -> T: ...
    def __rlshift__(self: T, other: typing.Any) -> T: ...
    def __ilshift__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __rshift__(self: T, other: typing.Any) -> T: ...
    def __rrshift__(self: T, other: typing.Any) -> T: ...
    def __irshift__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __and__(self: T, other: typing.Any) -> T: ...
    def __rand__(self: T, other: typing.Any) -> T: ...
    def __iand__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __xor__(self: T, other: typing.Any) -> T: ...
    def __rxor__(self: T, other: typing.Any) -> T: ...
    def __ixor__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def __or__(self: T, other: typing.Any) -> T: ...
    def __ror__(self: T, other: typing.Any) -> T: ...
    def __ior__(self: T, other: typing.Any) -> T: ...  # type: ignore[override]
    def byteswap(self: T, inplace: bool = ...) -> T: ...
    def squeeze(
        self: T,
        axis: None
        | typing.SupportsIndex
        | collections.abc.Sequence[typing.SupportsIndex] = ...,
    ) -> T: ...
    def swapaxes(
        self: T, axis1: typing.SupportsIndex, axis2: typing.SupportsIndex
    ) -> T: ...
    @typing.overload
    def transpose(self: T, axes: None | miot.ShapeLike, /) -> T: ...
    @typing.overload
    def transpose(self: T, *axes: typing.SupportsIndex) -> T: ...
    def dot(self, b: typing.Any, out: typing.Any = ...) -> typing.Any: ...
    def astype(  # type: ignore[override]
        self: T,
        dtype: npt.DTypeLike,
        order: typing.Literal["A", "C", "F", "K"] | None = ...,
        casting: typing.Literal["no", "equiv", "safe", "same_kind", "unsafe"] = ...,
        subok: bool = ...,
        copy: bool = ...,
    ) -> T: ...
    @typing.overload
    def reshape(
        self: T,
        shape: miot.ShapeLike,
        order: typing.Literal["A", "C", "F"] | None = ...,
    ) -> T: ...
    @typing.overload
    def reshape(
        self: T,
        *shape: typing.SupportsIndex,
        order: typing.Literal["A", "C", "F"] | None = ...,
    ) -> T: ...
    @typing.overload  # type: ignore[override]
    def view(self: T) -> T: ...
    @typing.overload
    def view(self: T, type: typing.Type[S]) -> S: ...
    @typing.overload
    def view(self: T, dtype: npt.DTypeLike) -> T: ...
    @typing.overload
    def view(self, dtype: npt.DTypeLike, type: typing.Type[S]) -> S: ...
    def flatten(
        self: T, order: typing.Literal["A", "C", "F", "K"] | None = ...
    ) -> T: ...
    def ravel(self: T, order: typing.Literal["A", "C", "F", "K"] | None = ...) -> T: ...
